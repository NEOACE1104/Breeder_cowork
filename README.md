# Cucumber 유전체 육종 웹 애플리케이션

본 프로젝트는 오이(Cucumber)의 유전체 및 표현체 데이터를 분석하여 유전체 예측(GP), 전장 유전체 연관 분석(GWAS), 최적 교배 조합 탐색 등을 수행하는 풀스택 웹 애플리케이션입니다.

## 기술 스택

- **백엔드**: FastAPI, SQLModel, SQLite, Pandas, Scikit-learn
- **프론트엔드**: React, Vite, TypeScript, Tailwind CSS, shadcn/ui, React Query, Recharts
- **배포**: Docker, Docker Compose

## 프로젝트 구조

```
.
├── backend/               # FastAPI 백엔드
│   ├── analysis/          # QC, GP, GWAS, Mating 로직
│   ├── api/               # API 엔드포인트
│   ├── core/              # 설정
│   ├── db/                # 데이터베이스 설정 및 초기화
│   ├── models/            # SQLModel 테이블 모델
│   ├── schemas/           # Pydantic API 스키마
│   ├── services/          # 비즈니스 로직 서비스
│   └── tests/             # 백엔드 테스트
├── data/                  # 샘플 데이터
├── frontend/              # React 프론트엔드
│   ├── src/
│   │   ├── api/
│   │   ├── components/    # 재사용 가능한 UI 컴포넌트
│   │   ├── i18n/          # 국제화 (한/영)
│   │   ├── lib/           # API 클라이언트, 유틸리티
│   │   ├── pages/         # 각 페이지 컴포넌트
│   │   └── ...
│   └── ...
├── results/               # 분석 결과가 저장되는 폴더 (자동 생성)
├── .env.example           # 환경 변수 템플릿
├── docker-compose.yml     # Docker 컨테이너 오케스트레이션
├── Dockerfile.backend     # 백엔드 Docker 이미지 빌드 파일
├── Dockerfile.frontend    # 프론트엔드 Docker 이미지 빌드 파일
└── README.md              # 프로젝트 문서
```

## 로컬 환경에서 실행 및 테스트

### 사전 요구사항

- Python 3.11+
- Node.js 20+ 및 pnpm (또는 npm/yarn)
- Docker 및 Docker Compose

### 1. 환경 설정

1.  **저장소 클론**:
    ```bash
    git clone <repository-url>
    cd <repository-directory>
    ```

2.  **환경 변수 파일 생성**:
    `.env.example` 파일을 복사하여 `.env` 파일을 생성합니다. 기본값으로도 로컬 실행이 가능합니다.
    ```bash
    cp .env.example .env
    ```

### 2. 로컬 직접 실행 (Vite HMR + FastAPI Reload)

이 방법은 개발에 가장 적합합니다.

1.  **백엔드 실행**:
    ```bash
    cd backend
    python -m venv venv
    source venv/bin/activate  # Windows: venv\Scripts\activate
    pip install -r ../requirements.txt
    cd ..
    uvicorn backend.main:app --reload
    ```
    백엔드 서버가 `http://127.0.0.1:8000`에서 실행됩니다.

2.  **프론트엔드 실행**:
    (다른 터미널에서)
    ```bash
    # pnpm 설치 (아직 없다면)
    # npm install -g pnpm
    pnpm install
    pnpm dev
    ```
    프론트엔드 개발 서버가 `http://localhost:5173`에서 실행됩니다. 이제 브라우저에서 이 주소로 접속하세요.

### 3. Docker로 실행

이 방법은 프로덕션과 유사한 환경에서 애플리케이션을 실행합니다.

```bash
docker-compose up --build
```

- 백엔드는 `http://localhost:8000`에서 접근 가능합니다.
- 프론트엔드는 `http://localhost:5173`에서 접근 가능합니다.

### 4. 테스트 실행

1.  **백엔드 테스트**:
    ```bash
    # 백엔드 가상환경 활성화
    # source backend/venv/bin/activate
    PYTHONPATH=. pytest
    ```

2.  **프론트엔드 테스트**:
    ```bash
    pnpm test
    ```

## API 계약 (요약)

- `POST /api/upload`: `training_dataset_integrated.csv` 업로드 및 DB 시딩
- `POST /api/qc/run`: QC 파이프라인 실행
- `POST /api/gwas/run`: GWAS 분석 실행
- `GET /api/results/{run_id}/{file_type}/{filename}`: 결과 파일(플롯, CSV) 다운로드

자세한 내용은 FastAPI 자동 문서 (`http://127.0.0.1:8000/docs`)에서 확인 가능합니다.

## 배포 가이드 (Render.com 예시)

1.  **GitHub 저장소에 프로젝트 푸시**

2.  **Render에서 'New Web Service' 생성 (백엔드)**
    - **Build Command**: `pip install -r requirements.txt && pip install gunicorn`
    - **Start Command**: `gunicorn -k uvicorn.workers.UvicornWorker -w 4 -b 0.0.0.0:8000 backend.main:app`
    - **Environment Variables**: `.env` 파일의 내용을 Render 환경 변수 설정에 추가합니다.
    - **Disk**: `app.db`와 `results` 폴더를 영속적으로 저장하기 위해 Disk를 추가하고 마운트 경로를 설정합니다. (`/app/app.db`, `/app/results`)

3.  **Render에서 'New Static Site' 생성 (프론트엔드)**
    - **Build Command**: `pnpm install && pnpm build`
    - **Publish Directory**: `frontend/dist`
    - **Rewrite/Redirect Rules**: 모든 요청을 `index.html`로 보내도록 설정하여 React Router가 작동하게 합니다.
      - Source: `/*`
      - Destination: `/index.html`
      - Action: Rewrite

## 가정 및 절충안 (Assumptions & Trade-offs)

- **데이터베이스**: MVP를 위해 경량의 SQLite를 사용했습니다. 대규모 데이터나 동시성 높은 환경에서는 PostgreSQL과 같은 프로덕션급 DB로 전환해야 합니다.
- **상태 관리**: 분석 데이터(행렬 등)는 서버의 인메모리 캐시에 저장됩니다. 이는 단일 인스턴스 환경에서는 빠르지만, 서버 재시작 시 데이터가 소실되며 스케일 아웃이 불가능합니다. 프로덕션에서는 Redis나 파일 기반 캐싱을 고려해야 합니다.
- **분석 모듈**: GP, Mating 기능은 UI상 플레이스홀더로 존재하며, 핵심 로직은 구현되었으나 API 연동 및 UI 구현이 필요합니다.
- **인증/인가**: 사용자를 구분하는 인증/인가 시스템은 구현되지 않았습니다. 모든 사용자가 모든 데이터에 접근할 수 있습니다.
- **결측치 처리**: 0 값을 결측치로 해석하는 로직은 특정 규칙에 기반하며, 데이터셋의 특성에 따라 조정이 필요할 수 있습니다.

---
*This project was generated by an AI assistant based on a detailed prompt.*
